// package main

// import (
// 	"database/sql"
// 	forum "forum/methods"
// 	"log"
// 	"net/http"
// 	"net/http/httptest"
// 	"os"
// 	"testing"

// 	_ "github.com/go-sql-driver/mysql"
// 	"github.com/gorilla/mux"
// 	_ "github.com/mattn/go-sqlite3"
// 	"github.com/stretchr/testify/assert"
// )

// func setup() {
// 	log.Println("Failing before database setup")
// 	// Initialize the test database connection
// 	testDB, err := sql.Open("mysql", os.Getenv("DB_CONNECTION_STRING"))
// 	if err != nil {
// 		log.Fatal(err)

// 	}
// 	log.Println("Failing after database setup")
// 	db = testDB
// }
// func teardown() {
// 	// Close the test database connection
// 	if err := db.Close(); err != nil {
// 		log.Fatal(err)
// 	}
// }

// func TestMain(m *testing.M) {
// 	setup()
// 	defer teardown()

// 	// Run the tests
// 	exitCode := m.Run()

// 	os.Exit(exitCode)
// }

// func Router() *mux.Router {
// 	router := mux.NewRouter()
// 	router.HandleFunc("/", forum.HandleMain).Methods("GET")
// 	return router
// }

// func TestRouter(t *testing.T) {
// 	router := Router()
// 	// Create a test HTTP request
// 	request := httptest.NewRequest("GET", "/", nil)

// 	// Create a test HTTP response recorder
// 	response := httptest.NewRecorder()

// 	// Serve the HTTP request to our router. This will populate the response.
// 	router.ServeHTTP(response, request)

// 	// Check the status code is what we expect.

// 	// if response.Code != http.StatusOK {
// 	// 	t.Errorf("Expected HTTP status %d, but got %d", http.StatusOK, response.Code)
// 	// }

// 	assert.Equal(t, http.StatusOK, response.Code, "OK response")
// }
